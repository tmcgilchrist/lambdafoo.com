<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>My Hakyll Blog - Minimal IRIX Kernel Driver</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/screen.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">My Hakyll Blog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../talks.html">Talks</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Minimal IRIX Kernel Driver</h1>

            <div class="info">
    Posted on January 31, 2008
    
</div>

<p>There are loads of articles and examples about how to develop a simple device driver for Linux or any of the BSDs, but outside of that there are very few. So why not have one for IRIX, it’s not exaclty the most common OS but there’s a good community around it at <a href="http://www.nekochan.net">Nekochan</a> and for anyone curious about Unix its a worthwhile task.</p>
<p>So presented here is a rather short “Hello, world” driver for the IRIX operating system.</p>
<ol type="1">
<li>Introduction</li>
<li>Basic Requirements</li>
<li>Kernel Driver</li>
<li>Compiling</li>
<li>Testing</li>
<li>Conclusion</li>
</ol>
<h3 id="introduction">1. Introduction</h3>
<p>This article is for anyone interested in kernel development under IRIX. It assumes that the reader has had previous exposure to C and is familar with some form of Unix, hopefully IRIX but Linux or *BSD is sufficient. There are already loads of similar articles showing how to get started with Linux or BSD drivers, but the only real resource for IRIX is SGIs monster <a href="http://techpubs.sgi.com/library/tpl/cgi-bin/browse.cgi?coll=0650&amp;db=bks&amp;cmd=toc&amp;pth=/SGI_Developer/DevDriver_PG">Device Driver</a> document. The problem I found with this document is, the depth of the material presented makes if difficult to know where to start from. So hopefully this article will provide a gentle introduction to IRIX before you jump into the SGI documentation.</p>
<h3 id="basic-requirements">2. Basic Requirements</h3>
<p>The main requirements for using the driver presented are: * root access to a SGI machine running IRIX 6.5 * MIPSPro Compiler</p>
<p>Unfortunately, these requirements may be a little difficult to fulfill but <a href="http://www.ebay.com">eBay</a> is your friend when looking for SGI equipment. All code was tested on an SGI O2 R10K 250Mhz running IRIX 6.5.27, and compiled with MIPSPro 7.3.</p>
<h3 id="kernel-driver">3. Kernel Driver</h3>
<p>The driver is very simple but provides a starting point for investigation about IRIX.</p>
<p>{% codeblock lang:c%}</p>
<p>#include &lt;sys/types.h&gt; #include &lt;sys/param.h&gt; #include &lt;sys/systm.h&gt; #include &lt;sys/sysmacros.h&gt; #include &lt;sys/ddi.h&gt;</p>
<p>/* ==================================================================== * Module version information, required for loadable modules. */</p>
<p>#include &lt;sys/mload.h&gt; char *sim_mversion = M_VERSION;</p>
<p>/* ==================================================================== * Device-Related Constants and Structures */</p>
<p>int sim_devflag = D_MP;</p>
<p>/* ================================================================== * FUNCTION TABLE OF CONTENTS */ void sim_init(void); int sim_unload(void); int sim_reg(void); int sim_unreg(void); int sim_open(dev_t devp, int oflag, int otyp, struct cred crp); int sim_close(dev_t dev, int oflag, int otyp, struct cred crp);</p>
<p>/<em> </em> For Irix6.4 compatability only, do nothing here. */ void sim_init(void) { printf(“sim_init()”); }</p>
<p>/<em> </em> Called by the kernel when the driver is loaded. * Here you’d do things like setup per device data and * register this driver for the hardware. */ int sim_reg(void) { printf(“sim_reg()”); return 0; }</p>
<p>/<em> </em> Unloads the driver. */ int sim_unload(void) { printf(“sim_unload()”); return 0; }</p>
<p>/<em> </em> Unregisters the driver. */ int sim_unreg(void) { printf(“sim_unreg()”); return 0; }</p>
<p>/<em> </em> Opens the driver. */ int sim_open(dev_t devp, int oflag, int otyp, struct cred crp) { printf(“sim_open()”); return 0; }</p>
<p>/<em> </em> Closes the driver. */ int sim_close(dev_t dev, int oflag, int otyp, struct cred crp) { printf(“sim_close()”); return 0; }</p>
<p>{% endcodeblock %}</p>
<h3 id="compiling">4. Compiling</h3>
<p>The major area missing from the SGI Driver manual is how to get your code to compile and load into the kernel. To help solve this problem a makefile has been provided and the important sections will be covered here.</p>
<p>{% codeblock lang:sh %} #!smake</p>
<p>CPUBOARD=IP32</p>
<p>{% endcodeblock %}</p>
<p>The first line is pretty self explainatory, run smake, which is a slightly different version of the standard unix make command. The CPUBOARD indicates which architecture to compile the driver for. The architecture differs between machines even if they have the same CPU so to find correct number run.</p>
<pre><code>hinv |grep IP</code></pre>
<p>which will printout the board number to use. I’m using an R10K in an O2, so my board number is IP32.</p>
<pre><code>include /var/sysgen/Makefile.kernloadio</code></pre>
<p>The file /var/sysgen/Makefile.kernloadio is a sample Makefile for kernel drivers, it sets up all the compiler and linker preferences for us. So far I’ve treated this as a black-box and haven’t changed anything in it, I assume the SGI engineers knew what they were doing.</p>
<pre><code>all: compile
compile:
    $(CC) $(CFLAGS) $(LDFLAGS) -c simple.c</code></pre>
<p>This is will compile the driver, and should be pretty familiar to any C coder.</p>
<pre><code>load:
    $(ML) ld -v -c simple.o -p sim -s 13

clean:
    $(RM) -f simple.o</code></pre>
<p>The load target here will do exactly what it says, load the driver into the kernel, and the clean will cleanup the files created. When running the ‘load’ target you may get an error like:</p>
<pre><code>-- load ---
/sbin/ml ld -v -c simple.o -p sim_ -s 13
Error loading module sim_: Major number already in use.
*** Error code 255
smake: Error: 1 error</code></pre>
<p>This is simply saying that an existing driver is using the major device number that we specified, so keep changing the number until it doesn’t clash. There must be some sort of logic to assigning major device numbers but it isn’t terribly important here.</p>
<h3 id="testing">5. Testing</h3>
<p>Being a simple dirver there isn’t a whole lot to test. The main thing is that it can be loaded and unloaded successfully, and that you can see the messages printed out when this happens. So open a new shell</p>
<pre><code>tail -f /var/adm/SYSLOG</code></pre>
<p>This will open the main logfile under IRIX so you can see the output of the driver. Now compile the driver and load the driver, you’ll need to be root for this to work.</p>
<pre><code>make &amp;&amp; make load</code></pre>
<p>Make a note of the id assigned to the driver, as it is required to unload it. Check that the driver has been loaded by listing all loadable drivers. The ml command is used for manipulating loadable kernel drivers, check out man ml for more details. In the other shell you should see something like</p>
<pre><code>Jan 31 01:34:20 6A:sgi unix: sim_init()
Jan 31 01:34:20 6A:sgi unix: sim_reg()
Jan 31 01:34:20 5E:sgi lboot: Module /usr/people/you/code/simple/simple.o dynamically loaded.</code></pre>
<p>To unload the driver use the id assigned to it earlier, eg 5 ml unld 5</p>
<p>In the other shell you should see</p>
<pre><code>Jan 31 01:34:20 6A:sgi unix: sim_unreg()
Jan 31 01:34:20 6A:sgi unix: sim_unload()</code></pre>
<h3 id="conclusion">6. Conclusion</h3>
<p>So now you should have a working driver for IRIX that can be modified to support any sort of hardware outlined in the <a href="http://techpubs.sgi.com/library/tpl/cgi-bin/browse.cgi?coll=0650&amp;db=bks&amp;cmd=toc&amp;pth=/SGI_Developer/DevDriver_PG">SGI Device Driver</a> document. There are plenty of more advanced examples of how to write drivers for PCI cards, SCSI, TCP/IP networking, amongst others. The PCI card examples are the most relevant if you have an O2 as they have PCI built in, unlike other SGI machines, and cheap PCI cards are everywhere, so you’ll always have good material to work with.</p>
<h3 id="extra">Extra</h3>
<p>Just an additional thing I came across when messing about withloadable drivers. Most of the examples in the SGI Device Driverdocument are for non-loadable drivers if you add the following sections you’ll be able to treat them as loadable drivers. A Loadable Driver will fail when attempting to load with this cryptic error message.</p>
<pre><code>Error loading module sim_:  Module version string is missing.
*** Error code 255</code></pre>
<p>This means that the loadable version string is missing from this driver. To fix add the following code to the driver, and the error should disappear.</p>
<pre><code> #include &lt;sys&gt;char *pfxmversion = M_VERSION;</code></pre>
<p>where <strong>pfx</strong> is the prefix used in the driver. In this article the prefix would be <strong>sim_</strong>.</p>
<h3 id="downloads">Downloads</h3>
<p>The source code is up on github: <a href="https://github.com/tmcgilchrist/simple_irix_driver">Simple IRIX Device Driver</a></p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
