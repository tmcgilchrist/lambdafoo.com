<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>My Hakyll Blog - Getting started with Sinan</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/screen.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">My Hakyll Blog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../talks.html">Talks</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>Getting started with Sinan</h1>

            <div class="info">
    Posted on September 10, 2012
    
</div>

<h2 id="background">Background</h2>
<p>When I started with Erlang I used a simple Makefile to call <code>erlc</code> and pretty much did things by hand. After a number of years in the wilderness I found out about <a href="http://github.com/basho/rebar">rebar</a> from Basho and started using that to compile my code. Everything was good, rebar knew how to compile OTP apps and pull down external dependencies. Except when I needed to generate releases. It’s not necessarily straight forward to get rebar to build you a nice release, <a href="http://www.metabrew.com/article/erlang-rebar-tutorial-generating-releases-upgrades">not that it’s impossible</a> it’s just not as simple as I’d like.</p>
<p>Enter Sinan, the somewhat forgotten erlang build tool.</p>
<p>Sinan is a build tool designed to build Erlang/OTP projects, releases and applications. It claims to be more OTP than rebar and uses the OTP metadata artefacts to build your project with little configuration needed.</p>
<p>Let’s see how well it delivers on the promise.</p>
<h2 id="sinan-from-scratch">Sinan From Scratch</h2>
<p>First you’ll need Erlang installed, which your friendly local package management tool should provide. I’m using Homebrew on OSX so I just did:</p>
<p>{% codeblock %} $ brew install erlang … $ erl -v Erlang R15B01 (erts-5.9.1) [source] [64-bit] [smp:8:8] [async-threads:0] [hipe] [kernel-poll:false]</p>
<p>Eshell V5.9.1 (abort with ^G) 1&gt; {% endcodeblock %} Linux should be similarly straight forward and Windows well you’re on your own.</p>
<p>Grab sinan from the <a href="https://github.com/erlware/sinan/downloads">downloads page</a> on github, I’m using version 4.1.1. Put it somewhere on your PATH, I’ve got mine in ~/bin which is on my PATH, and chmod +x it so it’s executable.</p>
<p>Now for the fun bit, type <code>sinan gen</code> and fill in the details.</p>
<p>{% codeblock %} Please specify your name your name&gt; Tim McGilchrist Please specify your email address your email&gt; timmcgil@gmail.com Please specify the copyright holder copyright holder (“Tim McGilchrist”)&gt; Please specify name of your project project name&gt; sinan_demo Please specify version of your project project version&gt; 0.0.1 Please specify the ERTS version (“5.9.1”)&gt; Is this a single application project (“n”)&gt; y Would you like a build config? (“y”)&gt; y Project was created, you should be good to go! {% endcodeblock %}</p>
<p>From that Sinan has generated a project, filling in your details, with an OTP application and some build configuration. Your directories should look something similar to this.</p>
<p>{% codeblock %} sinan_demo |– config | |– sys.config |– doc |– ebin | |– overview.edoc |– include |– sinan.config |– src | |– sinan_demo.app.src | |– sinan_demo_app.erl | |– sinan_demo_sup.erl {% endcodeblock %}</p>
<p>It includes all the standard directories you’d expect plus a <code>sinan.config</code> file.</p>
<p>First a little diversion, we need to add a line to the sinan config file, which tells sinan to include the erlang runtime system when it generates a release. Open sinan.config and add <code>{include_erts, true}.</code> as the last line. It should look like this:</p>
<p>{% codeblock lang:erlang %} {project_name, sinan_demo}. {project_vsn, “0.0.1”}.</p>
<p>{build_dir, &quot;_build&quot;}.</p>
<p>{ignore_dirs, [&quot;_“,”.&quot;]}.</p>
<p>{ignore_apps, []}.</p>
<p>{include_erts, true}.</p>
<p>{% endcodeblock %}</p>
<p>Back to making our generated code runnable.</p>
<p>By default the generated supervisor doesn’t point to a valid module so you’ll need to remedy that before trying to startup the application. Create a new file called <code>sinan_demo_server.erl</code> in <code>src</code> and drop the following code in.</p>
<p>{% codeblock lang:erlang %} -module(sinan_demo_server).</p>
<p>-behaviour(gen_server).</p>
<p>%% API -export([start_link/0, add_one/0, total/0]).</p>
<p>%% Callbacks -export([init/1, handle_call/3, handle_cast/2, handle_info/2, terminate/2, code_change/3]).</p>
<p>-record(state, {count}).</p>
<p>%%%=================================================================== %%% API functions %%%===================================================================</p>
<p>start_link() -&gt; gen_server:start_link({local, ?MODULE}, ?MODULE, [], []).</p>
<p>total() -&gt; gen_server:call(?MODULE, total).</p>
<p>add_one() -&gt; gen_server:call(?MODULE, add).</p>
<p>%%%=================================================================== %%% Callbacks %%%===================================================================</p>
<p>init([]) -&gt; io:format(“starting~n”, []), {ok, #state{count = 0}, 0}.</p>
<p>handle_call(add, _From, State) -&gt; NewCount = State#state.count + 1, NewState = State#state{count = NewCount}, Reply = {ok, NewState}, {reply, Reply, NewState}; handle_call(total, _From, State = #state{ count = Count }) -&gt; {reply, Count, State}; handle_call(Msg, _From, State) -&gt; {reply, {ok, Msg}, State}.</p>
<p>handle_cast(_Msg, State) -&gt; {noreply, State}.</p>
<p>handle_info(_Info, State) -&gt; {noreply, State}.</p>
<p>terminate(_Reason, _State) -&gt; ok.</p>
<p>code_change(_OldVsn, State, _Extra) -&gt; {ok, State}. {% endcodeblock %}</p>
<p>It’s a pretty standard OTP gen_server application with 2 API methods. <code>add_one/0</code> adds 1 to the counter and <code>total/0</code> returns the value of the counter. The record definition setups up the state record for this server with just a <code>count</code> attribute. The 2 API functions use the <code>gen_server:call/2</code> method to hit the OTP callback for <code>handle_call/3</code>.</p>
<p>Next we need to fix the supervisor so it starts the correct module. Change <code>sinan_demo_sup.erl</code> so it looks like the code below:</p>
<p>{% codeblock lang:erlang %} start_link() -&gt; supervisor:start_link({local, ?SERVER}, ?MODULE, []).</p>
<p>%%%=================================================================== %%% Supervisor callbacks %%%===================================================================</p>
<p>%% <span class="citation" data-cites="private">@private</span> -spec init(list()) -&gt; {ok, {SupFlags::any(), [ChildSpec::any()]}} | ignore | {error, Reason::any()}. init([]) -&gt; RestartStrategy = one_for_one, MaxRestarts = 1000, MaxSecondsBetweenRestarts = 3600,</p>
<pre><code>SupFlags = {RestartStrategy, MaxRestarts, MaxSecondsBetweenRestarts},

Restart = permanent,
Shutdown = 2000,
Type = worker,

AChild = {sinan_demo_server, {sinan_demo_server, start_link, []},
          Restart, Shutdown, Type, [sinan_demo_server]},

{ok, {SupFlags, [AChild]}}.</code></pre>
<p>{% endcodeblock %}</p>
<p>The 2 changes we have make is to <code>start_link/0</code> so we can call the server directly, and fix the child spec so it starts our new module.</p>
<p>Now we need to add the sinan_demo_server module to <code>sinan_demo.app.src</code> so we know about it when generating the OTP application. Just add it to the list of modules like so:</p>
<p>{% codeblock lang:erlang %} %% This is the application resource file (.app file) for the, %% application. {application, sinan_demo, [{description, “Sinan demo application.”}, {vsn, “0.0.1”}, {modules, [sinan_demo_app, sinan_demo_sup, sinan_demo_server]}, {registered,[sinan_demo_sup]}, {applications, [kernel, stdlib]}, {mod, {sinan_demo_app,[]}}, {start_phases, []}]}. {% endcodeblock %}</p>
<p>Compile with <code>sinan build</code> and hopefully everything works.</p>
<p>From here you’ve got a few options to get your application running, but the easiest is just to use the sinan shell and start your application from there.</p>
<p>{% codeblock %} $ sinan shell Eshell V5.9.1 (abort with ^G) 1&gt; application:which_applications(). [{parsetools,“XLATETOOLS CXC 138 xx”,“2.0.7”}, {syntax_tools,“Syntax tools”,“1.6.8”}, {compiler,“ERTS CXC 138 10”,“4.8.1”}, {getopt,“Command-line options parser for Erlang”,“0.4.2”}, {erlware_commons,“Additional standard library for Erlang”, “0.6.1”}, {stdlib,“ERTS CXC 138 10”,“1.18.1”}, {kernel,“ERTS CXC 138 10”,“2.15.1”}] 2&gt; application:start(sinan_demo). ok {% endcodeblock %}</p>
<p>We’ve started a shell and checked what applications are started with <code>application:which_applications()</code>. Now start the demo application with:</p>
<p>{% codeblock %} 3&gt; application:start(sinan_demo). ok {% endcodeblock %}</p>
<p>Now lets test that we can call the application.</p>
<p>{% codeblock %} 4&gt; sinan_demo_server:add_one(). {ok,{state,1}} 5&gt; sinan_demo_server:add_one(). {ok,{state,2}} {% endcodeblock %}</p>
<p>As you can see it’s calling the server and incrementing the call count.</p>
<p>The next step is to create a release, which is as simple as running <code>sinan release</code></p>
<p>Sinan has created a number of new directories under <code>_build</code></p>
<p>{% codeblock %} $ tree -d _build/ _build/ <code>-- sinan_demo         |-- bin         |-- erts-5.9.1         |-- lib         |   |-- kernel-2.15.1         |   |-- sinan_demo-0.0.1         |</code>– stdlib-1.18.1 <code>-- releases</code>– 0.0.1 {% endcodeblock %}</p>
<p>The <code>bin</code> directory is still there from last time but now we have an erts, lib and releases directories. erts is there because earlier we asked sinan to include an erlang runtime, so you can copy everything under _build/sinan_demo to another machine without erlang installed and run this application. The limitation being that the CPU and OS needs to match the machine you’ve built on. <code>lib</code> includes all the applications you asked sinan to include, they’ll match what you have in your collective .app.src files. <code>releases</code> contains configuration files specific to a particular release of the application.</p>
<p>Starting the release generated is as simple as</p>
<p>{% codeblock %} $ ./_build/sinan_demo/bin/sinan_demo Erlang R15B01 (erts-5.9.1) [source] [64-bit] [smp:8:8] [async-threads:0] [hipe] [kernel-poll:false]</p>
<p>starting Eshell V5.9.1 (abort with ^G) 1&gt; application:which_applications(). [{sinan_demo,“Sinan demo application.”,“0.0.1”}, {stdlib,“ERTS CXC 138 10”,“1.18.1”}, {kernel,“ERTS CXC 138 10”,“2.15.1”}] 2&gt; {% endcodeblock %}</p>
<p>We’ll leave it there for now, but if you’re curious like me you’ll probably have a bunch of questions of where to take sinan next.</p>
<p>Next time I’m going to cover:</p>
<ul>
<li>Generating Version 2</li>
<li>Doing an OTP upgrade to Version 2</li>
<li>Downgrading to Version 1</li>
</ul>
<p>But if you’ve got other suggestions please leave them in the comments.</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
