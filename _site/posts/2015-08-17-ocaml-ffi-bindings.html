<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>My Hakyll Blog - ocaml ffi bindings</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/screen.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">My Hakyll Blog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../talks.html">Talks</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>ocaml ffi bindings</h1>

            <div class="info">
    Posted on August 17, 2015
    
</div>

<p>One thing that always comes up with your favourite language is how do you use libraries written in another language. Typically this involves needing to talk to a particular C library, either because it’s faster than a native one or just that it is already written.</p>
<p>For OCaml there is the ctypes library for binding to C libraries using pure OCaml. Written by the people at the good people at OCaml Labs <a href="http://ocaml.io">http://ocaml.io</a></p>
<p>The core of ctypes is a set of combinators for describing the structure of C types – numeric types, arrays, pointers, structs, unions and functions. You can use these combinators to describe the types of the functions that you want to call, then bind directly to those functions – all without writing or generating any C!</p>
<p>Lets go through a simple example binding to libyaml. Here’s a declaration form libyaml to get the version string.</p>
<p>{% codeblock lang:c %}</p>
<p>/** * Get the library version as a string. <em> </em> <span class="citation" data-cites="returns">@returns</span> The function returns the pointer to a static string of the form * <span class="citation" data-cites="c">@c</span> “X.Y.Z”, where <span class="citation" data-cites="c">@c</span> X is the major version number, <span class="citation" data-cites="c">@c</span> Y is a minor version * number, and <span class="citation" data-cites="c">@c</span> Z is the patch version number. */</p>
<p>YAML_DECLARE(const char *) yaml_get_version_string(void);</p>
<p>{% endcodeblock %}</p>
<p>To bind to this we need to declare a compatible signature for our OCaml code.</p>
<p>{% codeblock lang:ocaml %}</p>
<p>open Ctypes open Foreign</p>
<p>let get_version_string = foreign “yaml_get_version_string” (void @-&gt; returning string)</p>
<p>{% endcodeblock %}</p>
<p>We’re pulling in Ctypes and Foreign. Then the let binding is using foreign with the name of the c method we want to call plus a type signature for that method.</p>
<p>Next we need some calling code to print out the version string.</p>
<p>{% codeblock lang:ocaml %} open Core.Std</p>
<p>let () = let version_string = get_version_string() in printf “Version: %s” version_string</p>
<p>{% endcodeblock %}</p>
<p>Assuming you’ve got opam installed you can get the dependencies <code>opam install core ctypes</code> and compile the whole thing.</p>
<p>{% codeblock lang:bash %}</p>
<blockquote>
<p>corebuild -pkg ctypes.foreign -lflags -cclib,-lyaml version_string.native … ./version_string.native Version: 0.1.6</p>
</blockquote>
<p>{% endcodeblock %}</p>
<p>We’ve got bindings to a native C library without writing any C.</p>
<p>More complicated example involving passing an allocated string back from C, lets look at the <code>proc_pidpath</code> call from OSX. This particular library call takes a process id (PID) and returns back</p>
<p>{% codeblock lang:c %} int proc_pidpath(int pid, void * buffer, uint32_t buffersize) {% endcodeblock %}</p>
<p>To bind to this call we again define a compatible signature.</p>
<p>{% codeblock lang:ocaml %} let pidpath = foreign ~check_errno:true “proc_pidpath” (int @-&gt; ptr char @-&gt; int @-&gt; returning int) {% endcodeblock %}</p>
<p>The arguments simply mirror those for the C library call, along with a new argument <code>check_errno</code> which indicates the c library sets errno if it encounters a problem.</p>
<p>http://stackoverflow.com/questions/22651910/returning-a-string-from-a-c-library-to-ocaml-using-ctypes-and-foreign</p>
<p>Ctypes provides native bindings for most things you’ll need. There’s all sorts of pointers and types matching pretty much every native C type you’ll need <a href="https://github.com/ocamllabs/ocaml-ctypes/blob/master/src/ctypes/ctypes.mli">here</a>.</p>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
