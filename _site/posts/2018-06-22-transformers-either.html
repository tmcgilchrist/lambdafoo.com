<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
    <head>
        <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
        <title>My Hakyll Blog - On EitherT</title>
        <link rel="stylesheet" type="text/css" href="../css/default.css" />
        <link rel="stylesheet" type="text/css" href="../css/screen.css" />
    </head>
    <body>
        <div id="header">
            <div id="logo">
                <a href="../">My Hakyll Blog</a>
            </div>
            <div id="navigation">
                <a href="../">Home</a>
                <a href="../about.html">About</a>
                <a href="../talks.html">Talks</a>
                <a href="../archive.html">Archive</a>
            </div>
        </div>

        <div id="content">
            <h1>On EitherT</h1>

            <div class="info">
    Posted on June 22, 2018
    
</div>

<p>In choosing Haskell as a language you sign up for a certain class of features and behaviours. e.g. lazy evaluation, static typing</p>
<p>This gives you a general point in the design space for general purpose languages but like all languages you are still left with a number of choices in building software. These choices are broad, diverse and hotly debated, sometimes they get labelled with <strong>Best Practices</strong> or the <strong>Right way</strong>. Like any good engineer you should recognise that everything involves trade-offs and that these labels are trying to hide that. There is not always one best way, an approach has positives and negatives. Knowing those trade offs and deliberately choosing an approach based off them is good engineering.</p>
<p>In programming language communities there are always bikeshedding arguments and Haskell is no different. I want to call out a particular point of view around using exceptions vs data types in Haskell when dealing with <em>errors</em>. Both are valid design points in a wider error handling design space. The exception path is widely associated with Snoyman, who has written much software and written extensively about this in <a href="https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell">Exceptions Best Practices in Haskell</a> and in the <a href="http://hackage.haskell.org/package/safe-exceptions">Safe Exceptions</a> package.</p>
<p>I’d like to highlight the negatives, as I see them, of that approach and suggest a different set of trade offs around modelling <em>errors</em> as data types using EitherT/ExceptT.</p>
<p>EitherT is a Monad Transformer built on the familar Either data type.</p>
<p>{%codeblock lang:haskell%} data Either a b = Left a | Right b {% endcodeblock %}</p>
<p>where typically <code>Left</code> represents some failure case in this context and <code>Right</code> represents success. Another formulation from OCaml community is:</p>
<p>{%codeblock lang:ocaml%} type (’a,’b) result = Ok of ’a | Error of ’b {% endcodeblock %}</p>
<p>which is more explicit about what the two constructors represent.</p>
<h2 id="async-exceptions">Async Exceptions</h2>
<p>Back in the beginning, actually in 2000/01, asynchronous exceptions were added to Haskell. [2] Quoting Simon Marlow:</p>
<blockquote>
<p>Basically it comes down to this: if we want to be able to interrupt purely functional code, asynchronous exceptions are the only way, because polling would be a side-effect.</p>
</blockquote>
<p>So Haskell has async exceptions whether you like them or not, the ship has sailed. This means that any code in <code>IO</code> can throw a runtime exception, further any thread can receive an async exception.</p>
<p>So, how should we best deal with this reality and structure our code?</p>
<h2 id="exceptions">Exceptions</h2>
<p>We have exceptions; lets use them.</p>
<p>To start doing that you need to define your own custom exception type.</p>
<p>{%codeblock lang:haskell%} data VapourError = InsufficientFunds | ItemUnavailable Text | MachineMalfunction Text deriving Typeable</p>
<p>– Write a reasonable Show instance for each error instance Show VapourError where show a = case a of InsufficientFunds -&gt; “Insufficient funds.” ItemUnavailable i -&gt; “Item” ++ i ++ &quot; unavailable.&quot; MachineMalfunction e -&gt; “Hardware malfunction” ++ e ++ “.”</p>
<p>instance Exception VapourError {%endcodeblock%}</p>
<p>The three steps we need are:</p>
<ol type="1">
<li>Build the custom error type as a data type</li>
<li>Provide a show instance, this could be generated but your error messages would not be great.</li>
<li>Make your custom error an instance of <code>Exception</code></li>
</ol>
<p>At this point you can use <code>throw</code>, <code>catch</code> and <code>handle</code> with your custom error type.</p>
<p>{%codeblock lang:haskell%} runVendingMachine :: VendingMachineState -&gt; Coin -&gt; IO Product runVendingMachine state coin = do unless (coin &gt; 0) $ throw InsufficientFunds dispenseItem state coin</p>
<p>dispenseItem :: VendingMachineState -&gt; Coin -&gt; IO VendingMachineState dispenseItem = …. {%endcodeblock%}</p>
<p>Looking at the signature of <code>runVendingMachine</code> you can see that it returns a <code>Product</code> by running a computation in <code>IO</code>. The problem you have when looking at that code is the signature doesn’t give you any indication that it might fail outside of the <code>IO</code> which we saw earlier can fail with anything. So as a consumer of this function, how are you to know what exceptions to catch. Your options are:</p>
<ul>
<li>Catch all exceptions - clearly dangerous and wrong</li>
<li>Catch a subset of exceptions - better but tricky to do correctly</li>
</ul>
<p>The first option is dangerous as catching all exceptions includes asynchronous exceptions like stack/heap overflow, thread killed and user interrupt. The documentation in <code>safe-exception</code> is particularly helpful here and I recommend you read it thoroughly, it is well written. The short version is you should only catch certain exceptions, trying to handle <code>StackOverflow</code>, <code>HeapOverflow</code> and <code>ThreadKilled</code> exceptions could cause your program to crash or behave in unexpected ways.</p>
<p>The second option is error prone. The process for finding the possible exceptions involves reading the source code and reading the haddock docs, with the goal of finding the set of sensible exceptions you need to put into a <code>catch</code> or <code>handle</code> call. Have you found all the places an exception might be thrown? What about if you pull in a new dependency, does it throw exceptions? What about a sub-dependency of a dependency?</p>
<p>What about the functions <code>runVendingMachine</code> calls? And their functions? To me it feels like going back to Javascript or Ruby land and giving up on some of the benefits of a typed language. I want the types to help me find the places I need to consider the errors, just like pattern matching does for data types.</p>
<p>The other less obvious (perhaps) issue is that you force the consumers of your function to know all the gory details of exceptions in Haskell, which ones are safe to catch and what to do. Getting this right is hard and tricky, and really belongs in a library so that it can be written one and reused.</p>
<p>Finally the behaviour of a Haskell system in production is such that throwing an exception would yield you exactly what the show instance for <code>VapourError</code> is. It wouldn’t give you a classic stack trace (unless you set that up) so you loose context where the exception was raised and what was happening around it. At a previous workplace we spend many weeks tracking down SSL and connection reset exceptions that occured in a base library but bubbled out through multiple layers of application code. It wasn’t fun.</p>
<p>This style is perfect for a quick script to munge some data, or an ICFP programming contest</p>
<p>If you really need exceptions, use <code>bracket</code> pattern or <code>safe-exceptions</code> like library. Keep the complexity contained and code needs to be written <em>very</em> carefully.</p>
<h2 id="data-types">Data Types</h2>
<p>We mentioned data types earlier, using data types to model your computation is the natural approach in Haskell. You build a data type that accurately reflects the data or states that you want to model. We even did it for the custom <code>VapourError</code> type earlier.</p>
<p>Extending that we will use a particular data type <code>EitherT</code> to model errors. This is a <code>monad transformer</code> with an <code>Either</code> where the monad could be anything.</p>
<p>In context it would look something like:</p>
<p>{%codeblock lang:haskell%} crankHandle :: Int -&gt; EitherT VapourError IO Product – or crankHandle :: Monad m =&gt; Int -&gt; EitherT VapourError m Product – or crankHandle :: MonadIO m =&gt; Int -&gt; EitherT VapourError m Product {%endcodeblock%}</p>
<p>The type of our error is present in the type of our function, a familar situation. If the monad <code>m</code> isn’t IO then we have a good degree of confidence that none of the base <code>exceptions</code> will be present.</p>
<h2 id="solution">Solution</h2>
<p>{%codeblock lang:haskell%}</p>
<h1 id="build-a-data-type-that-represents-the-possible-error-states">Build a data type that represents the possible error states</h1>
<p>data VapourError = InsufficientFunds | ItemUnavailable Text | MachineMalfunction Text</p>
<h1 id="provide-a-function-for-turning-errors-into-text">Provide a function for turning errors into text</h1>
<p>renderVapourError :: VapourError -&gt; Text renderVapourError = …</p>
<h1 id="usage-site">Usage site</h1>
<p>runVendingMachine :: VendingMachineState -&gt; Coin -&gt; EitherT VapourError IO Product runVendingMachine = … {% endcodeblock %}</p>
<h2 id="either---examples">Either - Examples</h2>
<p>Examples of substantial pieces of code using <code>EitherT</code> to organise errors.</p>
<ul>
<li>mafia - https://github.com/haskell-mafia/mafia/search?utf8=✓&amp;q=EitherT&amp;type=</li>
<li>boris - https://github.com/markhibberd/boris/search?utf8=✓&amp;q=EitherT&amp;type=</li>
<li>traction - https://github.com/markhibberd/traction/search?utf8=✓&amp;q=EitherT&amp;type=</li>
<li>mismi - https://github.com/nhibberd/mismi/search?q=EitherT&amp;type=Code&amp;utf8=✓</li>
</ul>
<h2 id="either-advantages">Either Advantages</h2>
<ul>
<li>function signatures clearly indicate error states</li>
<li>exhaustive pattern matching indicates where errors have/have not been handled</li>
<li>requires explicit composition of error data types</li>
</ul>
<p>Basically the compiler helps you handle the various states required using the type system.</p>
<h2 id="exception---examples">Exception - Examples</h2>
<p>Example of code using <code>Exceptions</code> to organise errors</p>
<ul>
<li>http-client - using non-200 response codes as exceptions</li>
<li>stack - internally follows an exception style</li>
</ul>
<h2 id="exception-disadvantages">Exception Disadvantages</h2>
<p>The main downsides as I see it to exception oriented code are:</p>
<ul>
<li>exception throwing functions compose too easily you are not forced to think about what it means.</li>
<li>no stack traces by default in Haskell mean you lose context.</li>
<li>handling exceptions requires knowledge about the internals of dependencies and how they use exceptions.</li>
</ul>
<p>Here the compiler is less helpful in guiding you, giving little or no help with handling particular exceptions or giving compile errors for new exceptions that you might need to consider.</p>
<h2 id="supporting-libraries">Supporting Libraries</h2>
<p>The supporting libraries for this pattern of error handling are:</p>
<ul>
<li>transformers-either - Provides a type alias <code>type EitherT = ExceptT</code> plus addition operators.</li>
<li>transformers-bifunctor - Provies bifunctors over a monad transformer.</li>
</ul>
<p>There is nothing revolutionary about <code>transformers-either</code>, you could roll your own version easily or use the <code>ExceptT</code> transformer provided in the <code>transformers</code> package (adding any helper functions you need). The value codes in a structured, consious handling of errors and using the Haskell compiler to help.</p>
<h2 id="conclusion">Conclusion</h2>
<blockquote>
<p>The primary value of avoiding exceptions is that it makes error behavior explicit in the type of the function. If you’re in an environment where everything might fail, being explicit about it is probably a negative. But if most of your function calls are total, then knowing which ones might fail highlights places where you should consider what the correct behavior is in the case of that failure. Remember that the failure of an individual step in your program doesn’t generally mean the overall failure of your code.</p>
<p>It’s a little bit like null-handling in languages without options. If everything might be null, well, option types probably don’t help you. But if most of the values you encounter in your program are guaranteed to be there, then tracking which ones might be null be tagging them as options is enormously helpful, since it draws your attention to the cases where it might be there, and so you get an opportunity to think about what the difference really is.</p>
</blockquote>
<blockquote>
<ul>
<li>Yaron Minsky</li>
</ul>
</blockquote>
<h2 id="references">References</h2>
<ol type="1">
<li><a href="https://simonmar.github.io/posts/2017-01-24/asynchronous-exceptions.html">Asynchronous Exceptions in Practice</a></li>
<li><a href="https://simonmar.github.io/bib/papers/async.pdf">Asynchronous Exceptions in Haskell</a></li>
<li><a href="https://www.fpcomplete.com/blog/2016/11/exceptions-best-practices-haskell">Exceptions Best Practices in Haskell</a></li>
<li><a href="https://www.fpcomplete/com/blog/2017/07/the-rio-monad">The RIO Monad</a></li>
<li><a href="https://discuss.ocaml.org/t/specific-reason-for-not-embracing-the-use-of-exceptions-for-error-propagation/1666/15">Yaron’s Thoughts</a></li>
<li><a href="https://www.well-typed.com/blog/2015/07/checked-exceptions/">Checked Exceptions</a></li>
</ol>

        </div>
        <div id="footer">
            Site proudly generated by
            <a href="http://jaspervdj.be/hakyll">Hakyll</a>
        </div>
    </body>
</html>
