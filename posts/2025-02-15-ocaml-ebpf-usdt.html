<?xml version="1.0" encoding="UTF-8" ?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">

  <head>
  <link href="http://gmpg.org/xfn/11" rel="profile">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta http-equiv="content-type" content="text/html; charset=utf-8">

  <!-- Enable responsiveness on mobile devices-->
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1">

  <title>
      
        Experimenting with OCaml and eBPF &middot; Perpetually Curious Blog
      
  </title>

  <!-- CSS -->
  <link rel="stylesheet" href="../css/poole.css">
  <link rel="stylesheet" href="../css/syntax.css">
  <link rel="stylesheet" href="../css/lanyon.css">
  <link rel="stylesheet" href="../css/book.css">
  <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=PT+Serif:400,400italic,700%7CPT+Sans:400">

  <!-- Icons -->
  <link rel="apple-touch-icon-precomposed" sizes="144x144" href="../images/apple-touch-icon-precomposed.png">
  <link rel="shortcut icon" href="../images/favicon.ico">

  <!-- RSS -->
  <link rel="alternate" type="application/rss+xml" title="RSS" href="../atom.xml">

  <!-- Google Analytics -->
  <script>
    (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
    (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
    m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
    })(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

    ga('create', 'UA-28532776-1', 'auto');
    ga('send', 'pageview');
  </script>
<!-- End Google Analytics -->
  <a rel="me" hidden="true" href="https://hachyderm.io/@tsmc">Mastodon</a>
</head>


  <body class="sidebar-overlay">

    <!-- Target for toggling the sidebar `.sidebar-checkbox` is for regular
     styles, `#sidebar-checkbox` for behavior. -->
<input type="checkbox" class="sidebar-checkbox" id="sidebar-checkbox">

<!-- Toggleable sidebar -->
<div class="sidebar" id="sidebar">

  <div class="sidebar-item">
    <img src="../images/tim-movember-2009.jpg" />
    <p>Tim McGilchrist</p>
    <p>Principal Software Engineer at Tarides</p>

    <p>
      Twitter: <a href="https://twitter.com/lambda_foo">@lambda_foo</a><br>
      Github: <a href="https://github.com/tmcgilchrist">tmcgilchrist</a><br>
      Email: <a href="mailto:timmcgil@gmail.com">timmcgil@gmail.com</a><br>
      LinkedIn: <a href="https://www.linkedin.com/in/timmcgilchrist">Tim McGilchrist</a>
    </p>

  </div>

  <nav class="sidebar-nav">
    <a class="sidebar-nav-item" href="../">
      Blog
    </a>
    <a class="sidebar-nav-item" href="../about">
      About
    </a>
    <a class="sidebar-nav-item" href="../talks">
      Talks
    </a>
    <p class="sidebar-nav-item">
      Feed:
      <a href="../rss.xml">
        RSS
      </a>
      /
      <a href="../atom.xml">
        Atom
      </a>
    </p>
  </nav>

  <div class="sidebar-item">
    <p>
      &copy; Tim McGilchrist 2007-2024
    </p>
    <p>
      Powered by Hakyll
    </p>
  </div>
</div>


    <!-- Wrap is the content to shift when toggling the sidebar. We wrap the
         content to avoid any CSS collisions with our real content. -->
    <div class="wrap">
      <div class="masthead">
        <div class="container">
          <h3 class="masthead-title">
            <a href="../" title="Home">Perpetually Curious Blog</a>
            
            <span class="masthead-links">
              <a href="../">Blog</a> |
              <a href="../pages/about.html">About</a> |
              <a href="../archive.html">Archive</a> |
              <a href="../pages/talks.html">Talks</a>
            </span>
          </h3>
        </div>
      </div>

      <div class="container content">
        <div class="post">
  <h1 class="post-title">Experimenting with OCaml and eBPF</h1>
  <span class="post-date">February 15, 2025</span>
  <p>Building on top of the excellent book <em>BPF Performance Tools</em> by Brendan Gregg. How can we apply the techniques from Chapter 12 Languages to OCaml?</p>
<p>First OCaml is roughly equivalent to C, it’s a compiled language with a runtime written in C. It supports frame pointers using the <code>--enable-frame-pointers</code> configuration option on x86_64, with ARM64 support in OCaml 5.4. Eventually the code we’re interested in is C or looks roughly like C but with a different calling convention.</p>
<p>For tracing into the Linux kernel, you’ll need a distribution that is compiled with frame pointers like Ubuntu 24.04 and we can reuse the kernel’s own symbol table. There are some exceptions for inlined functions and some blacklisted functions that aren’t safe to trace. However for the pieces I’ve looked at like memory allocation and virtual memory, it is fine.</p>
<p>For the OCaml runtime written in C, it can be configured to include symbols, frame pointers and debuginfo for the portions written in C. The sections of the runtime written in assembly have symbols and frame pointers. For actual OCaml code it will have symbols and frame pointers, with limited debuginfo. Demo time!</p>
<h1 id="ocaml-function-tracing">OCaml Function Tracing</h1>
<p>Given this test program taken from a bug report <a href="https://github.com/ocaml/ocaml/issues/13123">#13123</a> against OCaml.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode ocaml"><code class="sourceCode ocaml"><span id="cb1-1"><a href="#cb1-1" aria-hidden="true" tabindex="-1"></a><span class="co">(* Build with:</span></span>
<span id="cb1-2"><a href="#cb1-2" aria-hidden="true" tabindex="-1"></a><span class="co">  ocamlfind ocamlopt -package unix -package threads -thread -linkpkg -o liquidsoap_test.exe liquidsoap_test.ml *)</span></span>
<span id="cb1-3"><a href="#cb1-3" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> frame_size = <span class="fl">0.04</span></span>
<span id="cb1-4"><a href="#cb1-4" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> pcm_len = <span class="dt">int_of_float</span> (<span class="dv">44100</span>. *. frame_size)</span>
<span id="cb1-5"><a href="#cb1-5" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> channels = <span class="dv">2</span></span>
<span id="cb1-6"><a href="#cb1-6" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-7"><a href="#cb1-7" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> mk_pcm () = <span class="dt">Array</span>.init channels (<span class="kw">fun</span> _ -&gt; <span class="dt">Array</span>.make pcm_len <span class="dv">0</span>.)</span>
<span id="cb1-8"><a href="#cb1-8" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-9"><a href="#cb1-9" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> <span class="kw">rec</span> fn a =</span>
<span id="cb1-10"><a href="#cb1-10" aria-hidden="true" tabindex="-1"></a>  <span class="kw">if</span> <span class="dt">Array</span>.length a &lt;&gt; <span class="dv">0</span> <span class="kw">then</span></span>
<span id="cb1-11"><a href="#cb1-11" aria-hidden="true" tabindex="-1"></a>    <span class="dt">Gc</span>.full_major ();</span>
<span id="cb1-12"><a href="#cb1-12" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> pcm = mk_pcm () <span class="kw">in</span></span>
<span id="cb1-13"><a href="#cb1-13" aria-hidden="true" tabindex="-1"></a>  <span class="dt">ignore</span>(pcm);</span>
<span id="cb1-14"><a href="#cb1-14" aria-hidden="true" tabindex="-1"></a>  Unix.sleepf <span class="fl">0.04</span>;</span>
<span id="cb1-15"><a href="#cb1-15" aria-hidden="true" tabindex="-1"></a>  fn [||]</span>
<span id="cb1-16"><a href="#cb1-16" aria-hidden="true" tabindex="-1"></a></span>
<span id="cb1-17"><a href="#cb1-17" aria-hidden="true" tabindex="-1"></a><span class="kw">let</span> () =</span>
<span id="cb1-18"><a href="#cb1-18" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> deadweigth = <span class="dt">Array</span>.make (<span class="dv">40</span> * <span class="dv">1024</span> * <span class="dv">1024</span>) <span class="dv">1</span> <span class="kw">in</span></span>
<span id="cb1-19"><a href="#cb1-19" aria-hidden="true" tabindex="-1"></a>  Unix.sleepf <span class="fl">0.04</span>;</span>
<span id="cb1-20"><a href="#cb1-20" aria-hidden="true" tabindex="-1"></a>  <span class="kw">let</span> th = Thread.create fn deadweigth <span class="kw">in</span></span>
<span id="cb1-21"><a href="#cb1-21" aria-hidden="true" tabindex="-1"></a>  Thread.join th</span></code></pre></div>
<p>And an opam switch created with frame pointers.</p>
<pre class="shell"><code>$ opam switch create 5.3.0 5.3.0+options ocaml-option-fp

$ ocamlfind ocamlopt -package unix -package threads -thread \
  -linkpkg -o liquidsoap_test.exe liquidsoap_test.ml</code></pre>
<p>Running this code will print the PID each time the <code>liquidsoap_test.exe</code> executable is run.</p>
<pre class="shell"><code>$ sudo bpftrace -e 'uprobe:/home/tsmc/ocaml-performance/liquidsoap_test.exe:caml_start_program { printf(&quot;OCaml run with process ID %d\n&quot;, pid); }'</code></pre>
<p>Here we are using the information we know about OCaml startup, the <code>caml_start_program</code> is an assembly function that bridges the gap between the C startup code and OCaml, setting up the environment for the OCaml code. The section after <code>uprobe:</code> needs to point to the executable being run, change that if you want to trace something else.</p>
<p>Next, recall that we are dealing with a mix of regular C functions and OCaml functions. Listing the tracepoints available shows a mix of regular C functions prefixed with <code>caml_*</code> that are either part of the runtime or C primitives. OCaml compiler performs name mangling so anything coming from an OCaml source file will have a prefix <code>caml&lt;MODULE&gt;.</code> e.g. <code>camlStdlib__Domain*</code> for the <code>domain.ml</code> module from the standard library or <code>camlStdlib__Int.compare_296</code> for the compare function on Int. Armed with that knowledge. This command will list available probe points:</p>
<pre class="shell"><code>$ sudo bpftrace -l 'uprobe:/home/tsmc/ocaml-performance/liquidsoap_test.exe:*'</code></pre>
<p>If we wanted to count the number of function calls in a binary, we could do it like so:</p>
<pre class="shell"><code>$ cat count.bt
# Printout matched program
uprobe:/home/tsmc/ocaml-performance/liquidsoap_test.exe:caml_start_program
{
  printf(&quot;OCaml run with process ID %d\n&quot;, pid);
}

# Trace function calls
uprobe:/home/tsmc/ocaml-performance/liquidsoap_test.exe:camlLiquidsoap_test*
{
    @[probe] = count();
}

$ sudo bpftrace count.bt
Attaching 5 probes...
OCaml run with process ID 128477
^C

@[uprobe:/home/tsmc/ocaml-performance/liquidsoap_test.exe:camlLiquidsoap_test.entry]: 1
@[uprobe:/home/tsmc/ocaml-performance/liquidsoap_test.exe:camlLiquidsoap_test.fn_327]: 1
@[uprobe:/home/tsmc/ocaml-performance/liquidsoap_test.exe:camlLiquidsoap_test.mk_pcm_273]: 1029
@[uprobe:/home/tsmc/ocaml-performance/liquidsoap_test.exe:camlLiquidsoap_test.fun_601]: 2058</code></pre>
<p>Another thing we could do is see how much time is spent in the minor GC promotion function.</p>
<p>OCaml uses a bump-pointer allocator for the minor heap, when that is full it will call a C function to scan the minor heap, destroy the junk, and promote anything that survives into the major heap. I know that the main entry point for this is called <code>caml_empty_minor_heap_promote</code>. So this script will instrument the entry and exit for that function and print out a histogram of the time taken.</p>
<pre class="shell"><code># cat gcprofile.bt

uprobe:/home/tsmc/ocaml-performance/liquidsoap_test.exe:caml_start_program
{
  printf(&quot;Attaching to OCaml process ID %d\n&quot;, pid);
}

uprobe:/home/tsmc/ocaml-performance/liquidsoap_test.exe:caml_empty_minor_heap_promote
{
  @t = nsecs;
}

uretprobe:/home/tsmc/ocaml-performance/liquidsoap_test.exe:caml_empty_minor_heap_promote / @t /
{
  @minor_gc_times = hist(nsecs - @t);
}</code></pre>
<p>What about the major GC? The design of that is more complicated but I know <code>major_collection_slice</code> does the majority of the work, so we attach there.</p>
<pre class="shell"><code># cat gcprofile_major.bt

uprobe:/home/tsmc/ocaml-performance/liquidsoap_test.exe:caml_start_program
{
  printf(&quot;Attaching to OCaml process ID %d\n&quot;, pid);
}

uprobe:/home/tsmc/ocaml-performance/liquidsoap_test.exe:major_collection_slice
{
  @t = nsecs;
}

uretprobe:/home/tsmc/ocaml-performance/liquidsoap_test.exe:major_collection_slice / @t /
{
  @major_gc_slice_times = hist(nsecs - @t);
}</code></pre>
<h1 id="take-away">Take Away</h1>
<p>OCaml programs can traced with eBPF and bpftrace. You need to install OCaml with frame pointers enabled and use a Linux distribution like Ubuntu 24.04 that also enables frame pointers, so you can trace into system libraries. The OCaml runtime and certain primitives use a symbol prefix of <code>caml_</code> and OCaml code uses a prefix of <code>caml&lt;MODULE&gt;</code> where <code>&lt;MODULE&gt;</code> is the OCaml module containing the code. This partially covers the functionality in <a href="https://ocaml.org/manual/5.3/profil.html">ocamlprof</a> which lets you profile function counts and branches taken in things like while, if and try. With eBPF we can count the function calls but more work needs to be done to support the branching constructs, essentially we need a USDT implementation for OCaml that understands OCaml’s name mangling and calling conventions. The upside is eBPF can be applied to any OCaml binary without needing a recompile.</p>
<p>Next steps are adding USDT probes to the OCaml runtime, so there is a static API for the GC, and after that expose USDT probe points from OCaml programs.</p>
</div>


        <div class="container content">
          <small>Copyright © Tim McGilchrist 2007-2024</small>
          <br>
          <small>Powered by <a href="https://github.com/tmcgilchrist/lambdafoo.com">Hakyll</a></small>
        </div>
      </div>
    </div>

    <label for="sidebar-checkbox" class="sidebar-toggle"></label>

    <script>
      (function(document) {
        var toggle = document.querySelector('.sidebar-toggle');
        var sidebar = document.querySelector('#sidebar');
        var checkbox = document.querySelector('#sidebar-checkbox');

        document.addEventListener('click', function(e) {
          var target = e.target;

          if(!checkbox.checked ||
             sidebar.contains(target) ||
             (target === checkbox || target === toggle)) return;

          checkbox.checked = false;
        }, false);
      })(document);
    </script>
    </body>
</html>
